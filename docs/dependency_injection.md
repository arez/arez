---
title: Dependency Injection
---

Arez components provide several different mechanisms for integrating into dependency injection
frameworks. The two dependency injection frameworks that have seen the most use are
[Dagger2](https://google.github.io/dagger) and [Gin](https://code.google.com/archive/p/google-gin/).
This is due to Arez being primarily used within a web browser context.

Arez components consist of the authored component (i.e. `com.example.MyComponent`) and the enhanced
component class generated by the Arez annotation processor (i.e. `com.example.Arez_MyComponent`).

Arez mandates that dependencies are passed in to the constructor. Historically, Arez also supported injection
of dependencies into fields and methods but this resulted in increased code-size when compiled to javascript
and more complex code being generated. As a result constructor injection is now mandated.

When using Arez component in an application that uses dependency injection, the consuming code will receive a
reference to the component (i.e. `com.example.MyComponent`) as a constructor parameter. The consumer code looks
something like the following example:

{@file_content: file=arez/doc/examples/inject2/ExampleConsumer.java "start_line=public class"}

The `ExampleConsumer` class needs to be injected with the dependency; `MyService`. Every injection framework
uses a slightly different mechanism to determine how to construct and wire together a graph of objects however
a common strategy is to add an `@Inject` annotation to a single constructor for the type to be injected. Within
the context of Arez this means annotating a constructor in the enhanced class (i.e. `com.example.Arez_MyComponent`).

Arez will add the `@Inject` annotation to the constructor of the enhanced component if the
{@link: arez.annotations.ArezComponent#inject() inject} parameter on the
{@link: arez.annotations.ArezComponent @ArezComponent} is set to {@link: arez.annotations.Feature#ENABLE ENABLE}. If
the {@link: arez.annotations.ArezComponent#inject() inject} parameter is
{@link: arez.annotations.Feature#AUTODETECT AUTODETECT} and the base component is annotated with a "scope" annotation
then Arez will annotate the enhanced subclass with the same scope annotation and add an `@Inject` annotation to the
constructor.

This would be sufficient if the consumer code always consumed the enhanced classes but as this is rarely the
case, each injection framework has mechanisms that allow the framework to supply an instance of the enhanced
sub-class when the base class is requested. The way this is done is framework specific and Dagger integration
is covered in the following section.

## Dagger2

[Dagger2](https://google.github.io/dagger) is a modern take on a dependency injection framework that uses annotation
processors and statically checks the object graph at compilation time. The root objects in the graph are accessed via
a component which is an interface annotated by the `@dagger.Component` annotation. The injection rules are customized
via `@dagger.Module` annotated classes.

The {@link: arez.annotations.ArezComponent @ArezComponent} annotation has a
{@link: arez.annotations.ArezComponent#dagger() dagger} parameter that controls whether the Arez annotation processor
generates a Dagger module. If the value of the {@link: arez.annotations.ArezComponent#dagger() dagger} parameter is
{@link: arez.annotations.Feature#ENABLE ENABLE} or {@link: arez.annotations.Feature#AUTODETECT AUTODETECT} and the
`dagger.Component` class is on the classpath then a module will be generated that looks like:

{@file_content: path=generated/processors/main/java file=arez/doc/examples/inject2/MyServiceDaggerModule.java "start_line=@Generated"}

These can be incorporated into a dagger component like:

{@file_content: file=arez/doc/examples/inject2/ExampleDaggerComponent.java "start_line=@Singleton"}

And used in code like:

{@file_content: file=arez/doc/examples/inject2/DaggerExample.java "start_line=  {" "end_line=  }" include_start_line=false include_end_line=false strip_block=true}
