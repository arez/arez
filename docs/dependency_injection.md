---
title: Dependency Injection
---

Arez components provide several different mechanisms for integrating into dependency injection
frameworks. The two dependency injection frameworks that have seen the most use are
[Dagger2](https://google.github.io/dagger) and [GIN](https://code.google.com/archive/p/google-gin/).
This is due to Arez being primarily used within a web browser context.

Arez components typically consist of the base component (i.e. `com.example.MyComponent`), the enhanced
component class generated by the Arez annotation processor (i.e. `com.example.Arez_MyComponent`)
and optionally a generated base repository (i.e. `com.example.MyComponentRepository`) and an enhanced
repository class (i.e. `com.example.Arez_MyComponentRepository`). All but the base component are generated
by the annotation processor.

Typically when using Arez component in an application that uses dependency injection, the consuming
code will use the `@Inject` annotation to get references to the base component (i.e. `com.example.MyComponent`) or
the base repository (i.e. `com.example.MyComponentRepository`). The consumer code ends up looking
something like one of the following examples depending on whether field or constructor based injection
is used.

{@file_content: file=arez/doc/examples/inject1/ExampleConsumer.java "start_line=public class"}

{@file_content: file=arez/doc/examples/inject2/ExampleConsumer.java "start_line=public class"}

In both scenarios the `ExampleConsumer` class needs to be injected with two separate dependencies; `MyService`
and `MyEntityRepository`. Every injection framework uses a slightly different mechanism to determine how to
construct and wire together a graph of objects however a common strategy is to add an `@Inject` annotation to
a single constructor for the type to be injected. Within the context of Arez this means annotating a constructor
in the enhanced classes (i.e. `com.example.Arez_MyComponent` and `com.example.Arez_MyComponentRepository`).

Arez will add the `@Inject` annotation to the constructor of the enhanced component if the `inject` parameter
on the `@ArezComponent` is set to `ENABLE`. If the `inject` parameter is `AUTODETECT` and the base component is
annotated with a "scope" annotation then Arez will annotate the enhanced subclass with the same scope annotation
and add an `@Inject` annotation to the constructor.

The {@api_url: annotations.Repository} annotation has a similar `inject` parameter and the base repository will
be automatically annotated with the `@javax.inject.Singleton` scope annotation if the `javax.inject.Inject` class
is present.

This would be sufficient if the consumer code always consumed the enhanced classes but as this is rarely the
case, each injection framework has mechanisms that allow the framework to supply an instance of the enhanced
sub-class when the base class is requested. The way this is done is framework specific and is covered in the
following sections.

## GIN

[GIN](https://code.google.com/archive/p/google-gin/) is a extension of Guice 3.0 that runs under GWT. The root
objects in the object graph are accessed via a `Ginjector` and the injection rules can be customized by
supplying `GinModule` classes to the `Ginjector`. A `GinModule` that would expose the base classes in the
injection the framework is as simple as:

{@file_content: file=arez/doc/examples/inject2/ExampleGinModule.java "start_line=public class"}

Which could be linked up to a `Ginjector` like:

{@file_content: file=arez/doc/examples/inject2/ExampleGinjector.java "start_line=public interface"}

And used in code like:

{@file_content: file=arez/doc/examples/inject2/Example.java "start_line=  {" "end_line=  }" include_start_line=false include_end_line=false strip_block=true}

Gin was the injection framework of choice for GWT applications for a very long time and thus is present in
many existing GWT applications. However it is no longer under active development, has problems in modern
JVMs and is unlikely to be supported in GWT3.x so it's use is not recommended for modern GWT applications.

## Dagger2

[Dagger2](https://google.github.io/dagger) is a modern take on a dependency injection framework that uses annotation
processors and statically checks the object graph at compilation time. The root objects in the graph are accessed via
a component which is an interface annotated by the `@dagger.Component` annotation. The injection rules are customized
via `@dagger.Module` annotated classes.

Arez has greater support for the dagger injection framework than GIN. The {@api_url: annotations.ArezComponent}
and {@api_url: annotations.Repository} annotations have a `dagger` parameter that controls whether the Arez
annotation processor generates dagger modules.

If the value of the `dagger` parameter is `ENABLE` or `AUTODETECT` and the `dagger.Component` class is on the
classpath then a module will be generated for each base component and base repository that looks like:

{@file_content: path=generated/processors/main/java file=arez/doc/examples/inject2/MyServiceDaggerModule.java "start_line=@Generated"}

These can be incorporated into a dagger component like:

{@file_content: file=arez/doc/examples/inject2/ExampleDaggerComponent.java "start_line=@Singleton"}

And used in code like:

{@file_content: file=arez/doc/examples/inject2/DaggerExample.java "start_line=  {" "end_line=  }" include_start_line=false include_end_line=false strip_block=true}
