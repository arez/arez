---
title: Frequently Asked Questions
---

<AUTOGENERATED_TABLE_OF_CONTENTS>

## Application Development

### Why are @Autorun methods not being re-run when observable properties change?

Arez only re-runs {@api_url: annotations.Autorun} annotated methods if it is told that an observable property that
is a dependency of the {@api_url: annotations.Autorun} method is changed. Assuming you are using classes annotated
with {@api_url: annotations.ArezComponent}  then this means
that the code must:

* mutate the property using the setter method to mark the property as changed. The generated code ultimately calls
  the {@api_url: Observable.reportChanged()::Observable::reportChanged()} method to mark the property as changed.
* access the property using the getter method.. The generated code ultimately calls the
  {@api_url: Observable.reportObserved()::Observable::reportObserved()} method to mark the property as observed.
  This will add it as a dependency to the containing `@Autorun` method.

Typically this problem arises when you mutate field directly within the same class. Consider this problematic code
snippet:

```java
  @Observable
  public int getRemainingRides()
  {
    return _remainingRides;
  }

  public void setRemainingRides( int remainingRides )
  {
    _remainingRides = remainingRides;
  }

  @Action
  public void rideTrain()
  {
    _remainingRides = _remainingRides - 1;
  }
```

Compare it to this code that correctly notifies observers that the `remainingRides` property has updated. The only
difference is how the state is mutated within `rideTrain()` method.

```java
  @Observable
  public int getRemainingRides()
  {
    return _remainingRides;
  }

  public void setRemainingRides( int remainingRides )
  {
    _remainingRides = remainingRides;
  }

  @Action
  public void rideTrain()
  {
    setRemainingRides( getRemainingRides() - 1 );
  }
```

## Library Design

### Why do the change events/notifications not include a description of the change?

In many state management frameworks, notifications of change are accompanied by a description
of change but not so in Arez. For example in Arez the {@api_url: Observable.reportChanged()::Observable::reportChanged()}
method accepts no change description, the {@api_url: spy.ObservableChangedEvent} class
has no description of a change and there is no way for an {@api_url: Observer} to receive changes.

The reason is that change descriptions seem to be used as an optimization strategy needed in very specific
scenarios. For example, consider the scenario where you are representing an `Employee` as a react component
and you maintain a list of `Employee` instances that are candidates for a particular allowance. Calculating the
applicability of an allowance for a particular `Employee` is an expensive operation. In Arez you are forced to
regenerate the list of allowance candidates each time the set of `Employee` instances changes. In other
systems you could just listen for an event such as `EntityAdded(Employee)`, calculate the applicability for that
specific instance and insert them into the allowance candidates if appropriate. In that scenario the event
listen approach can be better optimized.

However building this in Arez with judicious use of {@api_url: annotations.Computed} annotated
methods can achieve acceptable performance, at least in our tests of up to ~8000 entities in the original `Employee`
set. It is possible that in the future, change messages will be added back into Arez but will only occur when
it is determined that the implementation and performance costs for other scenarios is worth the tradeoff.

This decision was not made lightly and the original Arez implementation included change events such as
`AtomicChange(FromValue, ToValue)`, `MapAdd(Key, Value)`, `Disposed()`, `UnspecifiedChange()` etc. These events
had to be queued on the `Observer` in the order they were generated and explicitly consumed by the `Observer`
during the reaction phase. This added some complexity to the Arez implementation. The author of Arez has also
previously implemented two other state management frameworks using this technique and considers the complexity
for downstream consumers to be the greatest problem with this strategy.

### Why is there not a @Memoize annotation for caching method calls?

[Memoization](https://en.wikipedia.org/wiki/Memoization) of expensive method calls seems like a good fit for
the Arez library and yet there is no `@Memoize` annotation that can be applied to {@api_url: annotations.ArezComponent}
annotated classes. There is no real reason why this feature is lacking other than a lack of time to implement it. An
initial spike implementation created a {@api_url: ComputedValue} instance for each
combination of unique parameters in method and seemed to work effectively. There was some complexity in the
implementation as testing for parameter equality needed to be configurable for each parameter and deactivation
typically triggered a dispose after a delay. Until this feature is implemented, it is reasonable easy to
implemented this with a {@api_url: annotations.Computed} annotation.

## Component Model

### Why do the generated/enhanced Arez components implement Disposable?

The enhanced component classes generated by the annotation processor all implement the {@api_url: Disposable}. This
makes it possible to explicitly decommission the reactive component and release all the Arez resources
associated with the component. A previous iteration of the framework made it optional for components to
support {@api_url: Disposable} but this just lead to resource leaks.

It should also be noted that all resources within a component are disposed within the scope of a single
transaction, to avoid scenario where a partially disposed component reacts to changes occurring during
dispose.

### Why does the annotation processor override equals() and hashCode() methods?

The annotation processor overrides the `equals()` and `hashCode()` methods as these methods
are used internally by Arez when storing instances of these classes. These methods are implemented with
the assumption that the component id is unique. If the component id is supplied by the toolkit user via
the {@api_url: annotations.ComponentId} annotation, the user must be careful to ensure that the component
id is unique.

### Why does the annotation processor only sometimes generate a toString() method?

The Arez annotation processor will generate a `toString()` method on a component if the user has not provided
their own `toString()` method. If any superclass other than the base `Object` class has overridden the `toString()`
method, then Arez assumes that the user will want to keep that method. If the method has not been overridden
then Arez will override `toString()` to return a value such as `"ArezComponent[myComponentName]"`. It should be
noted that if names are not enabled by the Arez compile time configuration (i.e.
{@api_url: Arez.areNamesEnabled()::Arez::areNamesEnabled()} returns false) then the base `Object.toString()`
method will be invoked.
