# TODO

This document is essentially a list of shorthand notes describing work yet to completed.
Unfortunately it is not complete enough for other people to pick work off the list and
complete as there is too much un-said.

## Enhancements

* Add react4j-sithtracker to website and testing regime

* Profile with D8
  - https://github.com/intendia-oss/rxjava-gwt#profiling-with-d8
  - http://blog.daniel-kurka.de/2014/01/profiling-gwt-applications-with-v8-and.html
  - https://v8.dev/docs/profile

* Add ErrorProne to build

* Should we add hooks that allow components to customize flags passed to created elements. The goal is to allow the
  component to dynamically customize configuration of a reactive element without defining a new class. i.e. Using
  the same class but allowing

* Why do zones not have a name? Why are Zones not part of serialized forms of events? - they should at least have a unique id

* Injectible components should run injector prior to postConstruct

* Can inverse references be maps. The key would be the component id.

* Add `ObservableMap`, `ObservableList` and `ObservableSet` implementations that implement reactivity as a
  wrapper around underling collections.

* Consider moving computable flags, action flags, task flags and observer flags into separate classes

* Consider naming patterns in `DisposeTrackable` and rename this interface. `DisposeNotifer` renamed to
  `DisposeTracker`? and made into interface with implementation in `internal` package?

* Rework the way `ArezBuildAsserts` is built by annotating fields in source code and generating assertions
  based on appropriate annotation magic. Should also be able to add annotations to methods. i.e. To ensure `toString()`
  is stripped if names not enabled.

* Consider merging OnActivate/OnDeactivate into mechanism like reacts new hooks where there is a single
  OnActivate method that that returns a `Disposable` which is call as `OnDeactivate`

* Add hook at end of scheduling so framework can do stuff (like batching spy message sent to DevTools)

* Maybe when the spy events are over a channel the puller can decide when parameters/results are sent across
  channel and when not.

* Investigate simplifying types via
  `public <T extends Throwable> void throwMeConditional(boolean conditional, T exception) throws T {`

* Add hit-ratios for `ComputableValue` instances that can be compiled out. The hit ratio indicates the number of times
  re-calculated versus number of actual changes. This will help us determine which `ComputableValue` instances
  are not useful. We should also include the average amount of time it took to calculate the value?

* Remove dependency on braincheck. Instead bring invariant checking inline and use invariant checking code
  that explicitly lists error code in call. i.e. `invariant( 213, () -> myCondition, () -> myFailMessage )`.
  We could also enhance the tests so that every invariant failure that is generated is written to a file
  and/or checked against a pattern. So a current error message like

    `Arez-0199: Observer.reportStale() invoked on observer named 'TestComponent1.0.render' but arezOnlyDependencies = true.`

  would be generated by code such as:

  `invariant( 199, () -> !arezOnlyDependencies(), () -> "Observer.reportStale() invoked on observer named '" + getName() + "' but arezOnlyDependencies = true." )`

  and would have a pattern to check against such as the following:

  `"Observer.reportStale() invoked on observer named '%s' but arezOnlyDependencies = true."`

  We could use this explicit modelling to help generate error messages and documentation on website. We could also use some trickery of reflection to extract
  the source file and line number where the invariant is generated. This would allow cross-linking from the website to the source code (via javadocs source
  inclusion).

  Enhance runtime so we link to website documentation for each numbered error. i.e. Arez-0022 could be linked
  to https://arez.github.io/errors.html#Arez-0022 For this we would need to enhanced the code that generates
  invariant failure and add documentation to the website.

  Whilst here we should add in an optional compile-time mechanisms by which invariant methods can verify that
  they are only called from within the appropriate guard. Not sure this is possible. This probably requires a
  custom rule in error prone.

  Some invariant violations should just generate warnings on console. These warnings could be upgraded to a
  failure or made so that they are only emitted the first time they are triggered based on compile time
  settings.

* Implement something similar to `getDependencyTree` from mobx

* Add per Observer `onError` parameter that can be used to replace the global reaction error handler.

* Consider adding per-task error handler and a global task error handler. Observer error handlers should
  be merged into this code  to reduce code size and conceptual overhead.

* Setup testing with browser. Headless Chrome via selenium? GWT test case?
  - https://thefriendlytester.co.uk/2017/04/new-headless-chrome-with-selenium.html
  - Perhaps by the latest kid in town - https://www.cypress.io/

* Should it be possible to suspend arbitrary observers?

* Enhance `BuildOutputTest` test to test multiple variants where we patch the build time constants for different
  build types.

* Complete the `arez-devtools` project.
  - Consider something like https://github.com/GoogleChromeLabs/comlink for comms
  - Embers DevTools is truly magical -  https://egghead.io/lessons/javascript-debug-ember-applications-using-ember-inspector

* Update `Observable.shouldGenerateUnmodifiableCollectionVariant()` and instead use `OnChanged` hook so that
  collections without a setter can potentially have an unmodified variant where the cache field is kept up to
  date.

* Add `defaultReadOutsideTransaction` and `defaultWriteOutsideTransaction` parameters to `@ArezComponent` that change
  the default value for the `readOutsideTransaction` and `writeOutsideTransaction` parameters on any `@Observable`
  properties on the component. The `default*` properties should not be specified unless there is actually `@Observable`
  properties in the component.

* Add a `readOutsideTransaction` parameter to `@Memoize` that controls whether it is valid to read value outside of
  an existing transaction. The default value for this will be impacted by the `defaultReadOutsideTransaction` parameter
  as defined above. The `writeOutsideTransaction` can also be set for `@Memoize` annotated methods that have external
  dependencies, in which case the `reportPossiblyChanged()` will not require an existing transaction? Or maybe will
  create an action on demand.

* Add test for `@Observable( writeOutsideTransaction = true, setterAlwaysMutates = false )` where call setter where
  no mutation occurs.

* Add support code into `ObservableValue` for setter generated by `@Observable( writeOutsideTransaction = true )` so
  that the same code is not duplicated through the models.

* Prime scheduler links:
  - https://github.com/spanicker/main-thread-scheduling
  - https://github.com/developit/task-worklet

* Enhance scheduler to support different categories of scheduled tasks:
  - See talk notes https://github.com/spanicker/main-thread-scheduling and sample code https://github.com/developit/task-worklet
  - User Blocking Tasks: input handlers + requestAnimationFrame + microTasks
  - Default tasks: (i.e scheduled tasks via `setTimeout()` and `postMessage()`)
  - Idle tasks: (i.e tasks scheduled but will only use time if any left before next render i.e. `requestIdleTimeout()`)

* Once the scheduler is in play it is likely we will want to implement code using `idle-until-urgent` strategy.
  Useful to delay some of the expensive setup for off screen stuff.
  - https://philipwalton.com/articles/idle-until-urgent/
  - https://github.com/GoogleChromeLabs/idlize/blob/master/IdleQueue.mjs
  - https://github.com/GoogleChromeLabs/idlize/blob/master/IdleValue.mjs

## Reactive-Streaming integration

* Experiment with controlling scheduling/executing of `@Computable`/`@Observe` methods at a later time. This
  could be in different schedulers (i.e. `requestAnimationFrame`) or via parameters like
  - `minimumDelay`: Must wait a minimum time before re-executing
  - `debounceTime`: Changes are ignored for a time after executing to avoid frequent changes
  - `throttleTime`: Track when executed and reschedule when at least `throttleTime` has passed. This is
    similar to `minimumDelay`, except that the initial run of the function happens immediately.
  This could probably be done via a reactive streaming library.

* Use a reactive streaming library (i.e. rxjava and ilk) that stream changes into `ComputableValue` instances. It would
  manually trigger `ComputableValue.reportPossiblyChanged()` when a new value arrives.

  The annotation processor should support a pair of methods. One that returns the stream definition and one that
  returns the value emitted by the stream.

* One useful addition may be the ability to push changes from `ObservableValue` instance and `ComputableValue`
  instances into streams. These changes could either be pushed inline within the `READ_WRITE` transaction or could
  be pushed as a task passed to scheduler. This would support several alternative approaches when architecting
  applications.

## TS/JS Integration

* It would be possible using J2CL to compile a version of Arez usable by vanilla Javascript, Typescript or Closure
  annotated javascript. For this to be useful it would be necessary to explicitly define a js API layer in a package
  such as `arez.js.*` that provides access to the `ArezContext` and factory methods in a fashion suitable for
  consumption by a js application. A component model for javascript applications would also need to be created
  which would most likely draw heavy inspiration from Mobx.

## Process

* A future version of BuildDownstream should only push out changes to downstream libraries IFF there already exists
  the patch branch {branch}-ArezUpgrade-{version}. The reason behind this is that all we are doing is checking that
  compilation works with the downstream project, however if compilation fails then the downstream project needs to
  publish a release as it indicates that there was some code change required. The other trigger for a release may be
  when the major version of arez changes.

* Setup tool that does comparisons between different versions of the API via a tool such as:
  - https://github.com/siom79/japicmp

* Consider a tool that creates branches in downstream branches if it does not exist and the build fails. This would
  make it easy to come along and update the branch as required.

## Documentation

* Update GitHub documentation - Add links to "How to create a [Minimal, Complete, and Verifiable](https://stackoverflow.com/help/mcve) example"
  in the issue templates as well as contributing doco.

* The Overview page is terrible - improve it so people would want to use the product.

* Document lifecycle of component. i.e. The order of operations

* Performance testing and writeup?

* Add Disposable to doco - i.e. explain how can dispose both components and reactive elements

* Add graph reflecting size of TodoMVC over time

* Change the documentation for the peer projects so that the `README.md` is converted into a package summary
  page in javadocs. Thus the README == the project documentation. We would need to link from README to the specific
  deployed page. Could do this by using qualified url in README and gsubing when converting to html.

## Mobx State Tree

* We could incorporate a mechanism like Mobx State Tree to serialize observable data of components as
  immutable json-like data. This may involve
  - adding additional lifecycle methods on the components (i.e. the equivalent of `onSnapshot()`)
  - working out mechanisms to determine how components in components are serialized (i.e references could
    be serialize component field or serialize id reference to field). Is the relationship a reference or
    containership.
  - deserialization strategies to various mediums (i.e. json etc) and how dow we resolve references. How
    do we do it late? Is this extracting a part of replicant into core Arez?
  - Interesting way to update and transmit changes via json patches
    https://medium.com/@mweststrate/distributing-state-changes-using-snapshots-patches-and-actions-part-1-2811a2fcd65f

## Incremental

* Incremental suggests that it may be useful to allow `ObservableValue`/`ComputableValue` nodes
  within Arez to update the list of nodes that depend upon it and select which dependents will be
  marked as STALE for a particular change. It may also be useful for `ComputableValue`/`Observer`
  nodes to receive a notification when a change would make it stale so that the node can incrementally
  update itself.
