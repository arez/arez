# TODO

This document is essentially a list of shorthand notes describing work yet to completed.
Unfortunately it is not complete enough for other people to pick work off the list and
complete as there is too much un-said.

## Next Version

* It should be possible to add `@CascadeDispose` to methods.

## Enhancements

* Remove dependency on braincheck. Instead bring invariant checking inline and use invariant checking code
  that explicitly lists error code in call. i.e. `invariant( 213, () -> myCondition, () -> myFailMessage )`.
  We could also enhance the tests so that every invariant failure that is generated is written to a file
  and/or checked against a pattern. So a current error message like

    `Arez-0199: Observer.reportStale() invoked on observer named 'TestComponent1.0.render' but arezOnlyDependencies = true.`

  would be generated by code such as:

  `invariant( 199, () -> !arezOnlyDependencies(), () -> "Observer.reportStale() invoked on observer named '" + getName() + "' but arezOnlyDependencies = true." )`

  and would have a pattern to check against such as the following:

  `"Observer.reportStale() invoked on observer named '%s' but arezOnlyDependencies = true."`

  We could use this explicit modelling to help generate error messages and documentation on website. We could also use some trickery of reflection to extract
  the source file and line number where the invariant is generated. This would allow cross-linking from the website to the source code (via javadocs source
  inclusion).

  Whilst here we should add in an optional compile-time mechanisms by which invariant methods can verify that
  they are only called from within the appropriate guard. Not sure this is possible.

* Add flag in `@Action`, and `@Track` annotations that will run transaction in Arez `ReactionEnvironment`.
  This flag will default to false.

* Implement something similar to `getDependencyTree` from mobx

* Remove `OnStale` as not very useful. However still needed to clear out cached immutable collections unless
  `@OnChange` has been introduced.

* Add per Observer `onError` parameter that can be used to replace the global reaction error handler.

* Profile with D8
  - https://github.com/intendia-oss/rxjava-gwt#profiling-with-d8
  - http://blog.daniel-kurka.de/2014/01/profiling-gwt-applications-with-v8-and.html

* Setup testing with browser. Headless Chrome via selenium? GWT test case?
  - https://thefriendlytester.co.uk/2017/04/new-headless-chrome-with-selenium.html
  - Perhaps by the latest kid in town - https://www.cypress.io/

* Should it be possible to suspend arbitrary observers?

* Enhance `BuildOutputTest` test to test multiple variants where we patch the build time constants for different
  build types.

* Completed the `arez-devtools` project.

* Support `@OnChanged` for `@Observable` and `@Computed` properties. This hook is called immediately after the
  change and includes the old value and the new value. The nullability annotations on the hook method should
  match expectations.

* Update `Observable.shouldGenerateUnmodifiableCollectionVariant()` and instead use `OnChanged` hook so that
  collections without a setter can potentially have an unmodified variant where the cache field is kept up to
  date.

* Support `@Reference` and `@ComponentDependency` on the same method? Alternatively we could assume that `@Reference`
  implies `@ComponentDependency` and allow configuration of cascade action onto reference?

* Add ArchUnit rules to codebase - https://github.com/TNG/ArchUnit

## Reactive-Streaming integration

* Experiment with controlling scheduling/executing of computed/observed methods at a later time. This
  could be in different schedulers (i.e. `requestAnimationFrame`) or via parameters like
  - `minimumDelay`: Must wait a minimum time before re-executing
  - `debounceTime`: Changes are ignored for a time after executing to avoid frequent changes
  - `throttleTime`: Track when executed and reschedule when at least `throttleTime` has passed. This is
    similar to `minimumDelay`, except that the initial run of the function happens immediately.
  This coul dprobably be done via a reactive streaming library.

* Use a reactive streaming library (i.e. rxjava and ilk) that stream changes into computed values. It would
  manually trigger `ComputedValue.reportPossiblyChanged()` when a new value arrives.

## Process

* A future version of BuildDownstream should only push out changes to downstream libraries IFF there already exists
  the patch branch {branch}-ArezUpgrade-{version}. The reason behind this is that all we are doing is checking that
  compilation works with the downstream project, however if compilation fails then the downstream project needs to
  publish a release as it indicates that there was some code change required. The other trigger for a release may be
  when the major version of arez changes.

* Setup tool that does comparisons between different versions of the API via a tool such as:
  - https://github.com/siom79/japicmp

## Documentation

* The Overview page is terrible - improve it so people would want to use the product.

* Document `@Reference`, `@ReferenceId`, `@Inverse`

* Document why `@Inverse` and `@Reference` duplicate information in FAQ - means both sides have to be updated
  if change so that glue code is correctly regenerated without forcing rebuild from tool.

* Document requirements on public API of `Observable`, `ComputedValue` etc. i.e. To call `reportObserved()`
  must be in transaction. To call `reportChanged()` must be in read-write transaction.

* Document lifecycle of component. i.e. The order of operations

* Performance testing and writeup?

* Add Disposable to doco - i.e. explain how can dispose both components and reactive elements

* Add graph reflecting size of TodoMVC over time

* Enhance runtime so we link to website documentation for each numbered error. i.e. Arez-0022 could be linked
  to https://arez.github.io/errors.html#Arez-0022 For this we would need to enhanced the code that generates
  invariant failure and add documentation to the website.

## Mobx State Tree

* We could incorporate a mechanism like Mobx State Tree to serialize observable data of components as
  immutable json-like data. This may involve
  - adding additional lifecycle methods on the components (i.e. the equivalent of `onSnapshot()`)
  - working out mechanisms to determine how components in components are serialized (i.e references could
    be serialize component field or serialize id reference to field). Is the relationship a reference or
    containership.
  - deserialization strategies to various mediums (i.e. json etc) and how dow we resolve references. How
    do we do it late? Is this extracting a part of replicant into core Arez?
  - Interesting way to update and transmit changes via json patches
    https://medium.com/@mweststrate/distributing-state-changes-using-snapshots-patches-and-actions-part-1-2811a2fcd65f

## Incremental

* An Ocaml framework that is very similar conceptually to Arez's core (Observable = variable,
  incremental = computed, observer = observer). They manually trigger scheduling (via stabilize call)
  and assume a DAG rather than a graph that will eventually stabilize.

* http://www.umut-acar.org/self-adjusting-computation
* https://blog.janestreet.com/introducing-incremental/

* Interestingly it also supports persistent data structures from functional programming paradigms. This
  feels very similar to the `CachedRelationship` from Rose.

* It also allows better control over which dependencies fire. i.e. Imagine you have a flag that indicates
  UI component that is selected. Each time it changes, all UI components need to refire to calculate boolean
  (probably `@Computed`) variable `"isSelected"`. Incremental can control dependencies that will fire and
  will only fire the two that need changing (i.e. the one going from selected to not selected and the one
  going from non selected to selected). It seems they do this by getting before and after values and and
  potentially dependency list and then writing custom change code. This approach is common when interacting
  with imperative API. VirtualDOM is like this. Compute the desired state, then perform diff against last
  state and perform patching against actual DOM to align. So get two variables (before VDOM, after VDOM)
  and use diff and patch operations to apply effects.

* It suggests that Arez should support some intelligent propagation of changes from Observables. Translating
  the concepts into Arez there seems to be two strategies for doing this. Allowing the observer to receive
  change messages that include the old state and the new state and writing the observer so that it can
  incrementally apply changes. It may also mean adding hooks to `Observable` and `ComputedValue` instances
  such that they can determine which dependencies that they will update on changes.

* https://github.com/janestreet/incremental
* https://www.youtube.com/watch?v=HNiFiLVg20k
