# TODO

This document is essentially a list of shorthand notes describing work yet to completed.
Unfortunately it is not complete enough for other people to pick work off the list and
complete as there is too much un-said.

## Enhancements

* Profile with D8
  - https://github.com/intendia-oss/rxjava-gwt#profiling-with-d8
  - http://blog.daniel-kurka.de/2014/01/profiling-gwt-applications-with-v8-and.html

* Add ErrorProne to build

* Rename `ArezContext.triggerScheduler()` to `ArezContext.triggerExecutor()` or something similar that
  indicates it is executing tasks but not doing clock based scheduling????

* Should we introduce an interface `SchedulerLock extends Disposable` that is returned from `pauseScheduler()`? 

* Consider moving computable flags, action flags, task flags and observer flags into separate classes

* Consider renaming `Executor.AREZ` to `Executor.INTERNAL` and `Executor.APPLICATION` to `Executor.EXTERNAL`

* Consider naming patterns in `DisposeTrackable` and rename this interface. `DisposeNotifer` renamed to
  `DisposeTracker`? and made into interface with implementation in `internal` package?

* Rework the way `ArezBuildAsserts` is built by annotating fields in source code and generating assertions
  based on appropriate annotation magic. Should also be able to add annotations to methods. i.e. To ensure `toString()`
  is stripped if names not enabled.

* Consider removing the notion of environments form within Arez as only used to call `batchedUpdates` in
  react and that already occurs during rendering and event handling. For the other scenarios (i.e. network
  events etc.) we could manually call it from relevant places.

* Consider merging OnActivate/OnDeactivate into mechanism like reacts new hooks where there is a single
  OnActivate method that that returns a `Disposable` which is call as `OnDeactivate`

* Add hook at end of scheduling so framework can do stuff (like batching spy message sent to DevTools)

* Maybe when the spy events are over a channel the puller can decide when parameters/results are sent across
  channel and when not.

* Investigate simplifying types via
  `public <T extends Throwable> void throwMeConditional(boolean conditional, T exception) throws T {`

* Add hit-ratios for `ComputableValue` instances that can be compiled out. The hit ratio indicates the number of times
  re-calculated versus number of actual changes. This will help us determine which `ComputableValue` instances
  are not useful. We should also include the average amount of time it took to calculate the value?

* Remove dependency on braincheck. Instead bring invariant checking inline and use invariant checking code
  that explicitly lists error code in call. i.e. `invariant( 213, () -> myCondition, () -> myFailMessage )`.
  We could also enhance the tests so that every invariant failure that is generated is written to a file
  and/or checked against a pattern. So a current error message like

    `Arez-0199: Observer.reportStale() invoked on observer named 'TestComponent1.0.render' but arezOnlyDependencies = true.`

  would be generated by code such as:

  `invariant( 199, () -> !arezOnlyDependencies(), () -> "Observer.reportStale() invoked on observer named '" + getName() + "' but arezOnlyDependencies = true." )`

  and would have a pattern to check against such as the following:

  `"Observer.reportStale() invoked on observer named '%s' but arezOnlyDependencies = true."`

  We could use this explicit modelling to help generate error messages and documentation on website. We could also use some trickery of reflection to extract
  the source file and line number where the invariant is generated. This would allow cross-linking from the website to the source code (via javadocs source
  inclusion).

  Enhance runtime so we link to website documentation for each numbered error. i.e. Arez-0022 could be linked
  to https://arez.github.io/errors.html#Arez-0022 For this we would need to enhanced the code that generates
  invariant failure and add documentation to the website.

  Whilst here we should add in an optional compile-time mechanisms by which invariant methods can verify that
  they are only called from within the appropriate guard. Not sure this is possible. This probably requires a
  custom rule in error prone.

  Some invariant violations should just generate warnings on console. These warnings could be upgraded to a
  failure or made so that they are only emitted the first time they are triggered based on compile time
  settings.

* Implement something similar to `getDependencyTree` from mobx

* Add per Observer `onError` parameter that can be used to replace the global reaction error handler.

* Consider adding per-task error handler and a global task error handler. Observer error handlers should
  be merged into this code  to reduce code size and conceptual overhead.

* Setup testing with browser. Headless Chrome via selenium? GWT test case?
  - https://thefriendlytester.co.uk/2017/04/new-headless-chrome-with-selenium.html
  - Perhaps by the latest kid in town - https://www.cypress.io/

* Should it be possible to suspend arbitrary observers?

* Enhance `BuildOutputTest` test to test multiple variants where we patch the build time constants for different
  build types.

* Complete the `arez-devtools` project.
  - Consider something like https://github.com/GoogleChromeLabs/comlink for comms
  - Embers DevTools is truly magical -  https://egghead.io/lessons/javascript-debug-ember-applications-using-ember-inspector

* Update `Observable.shouldGenerateUnmodifiableCollectionVariant()` and instead use `OnChanged` hook so that
  collections without a setter can potentially have an unmodified variant where the cache field is kept up to
  date.

* Enhance scheduler and expose the ability to add deferred tasks.
  - https://philipwalton.com/articles/idle-until-urgent/
  - https://github.com/GoogleChromeLabs/idlize/blob/master/IdleQueue.mjs
  - https://github.com/GoogleChromeLabs/idlize/blob/master/IdleValue.mjs

* Enhance scheduler to support different categories of scheduled tasks:
  - See talk notes https://github.com/spanicker/main-thread-scheduling and sample code https://github.com/developit/task-worklet
  - User Blocking Tasks: input handlers + requestAnimationFrame + microTasks
  - Default tasks: (i.e scheduled tasks via `setTimeout()` and `postMessage()`)
  - Idle tasks: (i.e tasks scheduled but will only use time if any left before next render i.e. `requestIdleTimeout()`)

* Once the scheduler is in play it is likely we will want to implement code using `idle-until-urgent` strategy.
  Useful to delay some of the expensive setup for off screen stuff. See https://philipwalton.com/articles/idle-until-urgent/

## Reactive-Streaming integration

* Experiment with controlling scheduling/executing of `@Computable`/`@Observe` methods at a later time. This
  could be in different schedulers (i.e. `requestAnimationFrame`) or via parameters like
  - `minimumDelay`: Must wait a minimum time before re-executing
  - `debounceTime`: Changes are ignored for a time after executing to avoid frequent changes
  - `throttleTime`: Track when executed and reschedule when at least `throttleTime` has passed. This is
    similar to `minimumDelay`, except that the initial run of the function happens immediately.
  This could probably be done via a reactive streaming library.

* Use a reactive streaming library (i.e. rxjava and ilk) that stream changes into `ComputableValue` instances. It would
  manually trigger `ComputableValue.reportPossiblyChanged()` when a new value arrives.

  The annotation processor should support a pair of methods. One that returns the stream definition and one that
  returns the value emitted by the stream.

* One useful addition may be the ability to push changes from `ObservableValue` instance and `ComputableValue`
  instances into streams. These changes could either be pushed inline within the `READ_WRITE` transaction or could
  be pushed as a task passed to scheduler. This would support several alternative approaches when architecting
  applications.

## TS/JS Integration

* It would be possible using J2CL to compile a version of Arez usable by vanilla Javascript, Typescript or Closure
  annotated javascript. For this to be useful it would be necessary to explicitly define a js API layer in a package
  such as `arez.js.*` that provides access to the `ArezContext` and factory methods in a fashion suitable for
  consumption by a js application. A component model for javascript applications would also need to be created
  which would most likely draw heavy inspiration from Mobx.

## Process

* A future version of BuildDownstream should only push out changes to downstream libraries IFF there already exists
  the patch branch {branch}-ArezUpgrade-{version}. The reason behind this is that all we are doing is checking that
  compilation works with the downstream project, however if compilation fails then the downstream project needs to
  publish a release as it indicates that there was some code change required. The other trigger for a release may be
  when the major version of arez changes.

* Setup tool that does comparisons between different versions of the API via a tool such as:
  - https://github.com/siom79/japicmp

* Consider a tool that creates branches in downstream branches if it does not exist and the build fails. This would
  make it easy to come along and update the branch as required.

## Documentation

* The Overview page is terrible - improve it so people would want to use the product.

* Document lifecycle of component. i.e. The order of operations

* Performance testing and writeup?

* Add Disposable to doco - i.e. explain how can dispose both components and reactive elements

* Add graph reflecting size of TodoMVC over time

* Change the documentation for the peer projects so that the `README.md` is converted into a package summary
  page in javadocs. Thus the README == the project documentation. We would need to link from README to the specific
  deployed page. Could do this by using qualified url in README and gsubing when converting to html.

## Mobx State Tree

* We could incorporate a mechanism like Mobx State Tree to serialize observable data of components as
  immutable json-like data. This may involve
  - adding additional lifecycle methods on the components (i.e. the equivalent of `onSnapshot()`)
  - working out mechanisms to determine how components in components are serialized (i.e references could
    be serialize component field or serialize id reference to field). Is the relationship a reference or
    containership.
  - deserialization strategies to various mediums (i.e. json etc) and how dow we resolve references. How
    do we do it late? Is this extracting a part of replicant into core Arez?
  - Interesting way to update and transmit changes via json patches
    https://medium.com/@mweststrate/distributing-state-changes-using-snapshots-patches-and-actions-part-1-2811a2fcd65f

## Incremental

* An Ocaml framework that is very similar conceptually to Arez's core (ObservableValue = variable,
  ComputableValue = incremental, Observer = observer). They manually trigger scheduling (via stabilize call)
  and assume a DAG rather than a graph that will eventually stabilize.

* http://www.umut-acar.org/self-adjusting-computation
* https://blog.janestreet.com/introducing-incremental/

* Interestingly it also supports persistent data structures from functional programming paradigms. This
  feels very similar to the `CachedRelationship` from Rose.

* It also allows better control over which dependencies fire. i.e. Imagine you have a flag that indicates
  UI component that is selected. Each time it changes, all UI components need to re-fire to calculate boolean
  (probably `@Computable`) variable `"isSelected"`. Incremental can control dependencies that will fire and
  will only fire the two that need changing (i.e. the one going from selected to not selected and the one
  going from non selected to selected). It seems they do this by getting before and after values and and
  potentially dependency list and then writing custom change code. This approach is common when interacting
  with imperative API. VirtualDOM is like this. Compute the desired state, then perform diff against last
  state and perform patching against actual DOM to align. So get two variables (before VDOM, after VDOM)
  and use diff and patch operations to apply effects.

* It suggests that Arez should support some intelligent propagation of changes from Observables. Translating
  the concepts into Arez there seems to be two strategies for doing this. Allowing the observer to receive
  change messages that include the old state and the new state and writing the observer so that it can
  incrementally apply changes. It may also mean adding hooks to `Observable` and `ComputableValue` instances
  such that they can determine which dependencies that they will update on changes.

* https://github.com/janestreet/incremental
* https://www.youtube.com/watch?v=HNiFiLVg20k
