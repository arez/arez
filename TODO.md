# TODO

This document is essentially a list of shorthand notes describing work yet to completed.
Unfortunately it is not complete enough for other people to pick work off the list and
complete as there is too much un-said.

## Enhancements

* Consider removing -ed from event names? Some signal before the underlying action and some after.

* Add hook at end of scheduling so framework can do stuff (like batching spy message sent to DevTools)

* `ComputableValue` should expose `activate()` and `deactivate()` methods so we can make the value "hot" (a.k.a temporarily
  `KEEPALIVE`) and then make it "cold" again later. Perhaps a better approach is to add a `Disposable warm()` that is
  backed by counter and only deactivates if counter is 0 and no listeners.

* Maybe when the spy events are over a channel the puller can decide when parameters/results are sent across
  channel and when not.

* Rename `ObserverError.REACTION_ERROR` to `ObserverError.OBSERVE_ERROR`

* Investigate simplifying types via
  `public <T extends Throwable> void throwMeConditional(boolean conditional, T exception) throws T {`

* Merge `@Computed` into `@Memoize`. This changes the validation significantly and how code is generated. The
  first step is to ensure that the `@ComputableValueRef`, `@OnActivate`, `@OnDeactivate` and `@OnStale` annotated
  methods are only valid when the `@Memoize` method takes no parameters. The next step is to restructure
  `@ComputableValueRef` so that it accepts parameters that are memoized and potentially the other hook methods.

* Add hit-ratios for `@Computed` that could be compiled out. The hit ratio indicates the number of times
  re-calculated versus number of actual changes. This will help us determine which `@Computed` instances
  are not useful. We should also include the average amount of time it took to calculate the value?

* Remove dependency on braincheck. Instead bring invariant checking inline and use invariant checking code
  that explicitly lists error code in call. i.e. `invariant( 213, () -> myCondition, () -> myFailMessage )`.
  We could also enhance the tests so that every invariant failure that is generated is written to a file
  and/or checked against a pattern. So a current error message like

    `Arez-0199: Observer.reportStale() invoked on observer named 'TestComponent1.0.render' but arezOnlyDependencies = true.`

  would be generated by code such as:

  `invariant( 199, () -> !arezOnlyDependencies(), () -> "Observer.reportStale() invoked on observer named '" + getName() + "' but arezOnlyDependencies = true." )`

  and would have a pattern to check against such as the following:

  `"Observer.reportStale() invoked on observer named '%s' but arezOnlyDependencies = true."`

  We could use this explicit modelling to help generate error messages and documentation on website. We could also use some trickery of reflection to extract
  the source file and line number where the invariant is generated. This would allow cross-linking from the website to the source code (via javadocs source
  inclusion).

  Enhance runtime so we link to website documentation for each numbered error. i.e. Arez-0022 could be linked
  to https://arez.github.io/errors.html#Arez-0022 For this we would need to enhanced the code that generates
  invariant failure and add documentation to the website.

  Whilst here we should add in an optional compile-time mechanisms by which invariant methods can verify that
  they are only called from within the appropriate guard. Not sure this is possible.

  Some invariant violations should just generate warnings on console. These warnings could be upgraded to a
  failure or made so that they are only emitted the first time they are triggered based on compile time
  settings.

* Implement something similar to `getDependencyTree` from mobx

* Remove `OnStale` as not very useful. However still needed to clear out cached immutable collections unless
  `@OnChange` has been introduced.

* Add per Observer `onError` parameter that can be used to replace the global reaction error handler.

* Profile with D8
  - https://github.com/intendia-oss/rxjava-gwt#profiling-with-d8
  - http://blog.daniel-kurka.de/2014/01/profiling-gwt-applications-with-v8-and.html

* Setup testing with browser. Headless Chrome via selenium? GWT test case?
  - https://thefriendlytester.co.uk/2017/04/new-headless-chrome-with-selenium.html
  - Perhaps by the latest kid in town - https://www.cypress.io/

* Should it be possible to suspend arbitrary observers?

* Enhance `BuildOutputTest` test to test multiple variants where we patch the build time constants for different
  build types.

* Completed the `arez-devtools` project.

* Support `@OnChange` for `@Observable` and `@Computed` properties. This hook is called immediately after the
  change and includes the old value and the new value. The nullability annotations on the hook method should
  match expectations.

* Update `Observable.shouldGenerateUnmodifiableCollectionVariant()` and instead use `OnChanged` hook so that
  collections without a setter can potentially have an unmodified variant where the cache field is kept up to
  date.

## Reactive-Streaming integration

* Experiment with controlling scheduling/executing of `@Computable`/`@Observe` methods at a later time. This
  could be in different schedulers (i.e. `requestAnimationFrame`) or via parameters like
  - `minimumDelay`: Must wait a minimum time before re-executing
  - `debounceTime`: Changes are ignored for a time after executing to avoid frequent changes
  - `throttleTime`: Track when executed and reschedule when at least `throttleTime` has passed. This is
    similar to `minimumDelay`, except that the initial run of the function happens immediately.
  This could probably be done via a reactive streaming library.

* Use a reactive streaming library (i.e. rxjava and ilk) that stream changes into `ComputableValue` instances. It would
  manually trigger `ComputableValue.reportPossiblyChanged()` when a new value arrives.

## Process

* A future version of BuildDownstream should only push out changes to downstream libraries IFF there already exists
  the patch branch {branch}-ArezUpgrade-{version}. The reason behind this is that all we are doing is checking that
  compilation works with the downstream project, however if compilation fails then the downstream project needs to
  publish a release as it indicates that there was some code change required. The other trigger for a release may be
  when the major version of arez changes.

* Setup tool that does comparisons between different versions of the API via a tool such as:
  - https://github.com/siom79/japicmp

## Documentation

* The Overview page is terrible - improve it so people would want to use the product.

* Document lifecycle of component. i.e. The order of operations

* Performance testing and writeup?

* Add Disposable to doco - i.e. explain how can dispose both components and reactive elements

* Add graph reflecting size of TodoMVC over time

* Change the documentation for the peer projects so that the `README.md` is converted into a package summary
  page in javadocs. Thus the README == the project documentation. We would need to link from README to the specific
  deployed page. Could do this by using qualified url in README and gsubing when converting to html.

## Mobx State Tree

* We could incorporate a mechanism like Mobx State Tree to serialize observable data of components as
  immutable json-like data. This may involve
  - adding additional lifecycle methods on the components (i.e. the equivalent of `onSnapshot()`)
  - working out mechanisms to determine how components in components are serialized (i.e references could
    be serialize component field or serialize id reference to field). Is the relationship a reference or
    containership.
  - deserialization strategies to various mediums (i.e. json etc) and how dow we resolve references. How
    do we do it late? Is this extracting a part of replicant into core Arez?
  - Interesting way to update and transmit changes via json patches
    https://medium.com/@mweststrate/distributing-state-changes-using-snapshots-patches-and-actions-part-1-2811a2fcd65f

## Incremental

* An Ocaml framework that is very similar conceptually to Arez's core (ObservableValue = variable,
  ComputableValue = incremental, Observer = observer). They manually trigger scheduling (via stabilize call)
  and assume a DAG rather than a graph that will eventually stabilize.

* http://www.umut-acar.org/self-adjusting-computation
* https://blog.janestreet.com/introducing-incremental/

* Interestingly it also supports persistent data structures from functional programming paradigms. This
  feels very similar to the `CachedRelationship` from Rose.

* It also allows better control over which dependencies fire. i.e. Imagine you have a flag that indicates
  UI component that is selected. Each time it changes, all UI components need to re-fire to calculate boolean
  (probably `@Computable`) variable `"isSelected"`. Incremental can control dependencies that will fire and
  will only fire the two that need changing (i.e. the one going from selected to not selected and the one
  going from non selected to selected). It seems they do this by getting before and after values and and
  potentially dependency list and then writing custom change code. This approach is common when interacting
  with imperative API. VirtualDOM is like this. Compute the desired state, then perform diff against last
  state and perform patching against actual DOM to align. So get two variables (before VDOM, after VDOM)
  and use diff and patch operations to apply effects.

* It suggests that Arez should support some intelligent propagation of changes from Observables. Translating
  the concepts into Arez there seems to be two strategies for doing this. Allowing the observer to receive
  change messages that include the old state and the new state and writing the observer so that it can
  incrementally apply changes. It may also mean adding hooks to `Observable` and `ComputableValue` instances
  such that they can determine which dependencies that they will update on changes.

* https://github.com/janestreet/incremental
* https://www.youtube.com/watch?v=HNiFiLVg20k
